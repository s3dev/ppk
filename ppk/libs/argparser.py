#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
:Purpose:   This module provides the command line argument parser for
            the project.

:Platform:  Linux/Windows | Python 3.6+
:Developer: J Berendt
:Email:     development@s3dev.uk

:Comments:  n/a

"""
# pylint: disable=import-error

import argparse
import os
import sys
# locals
from ppk.libs.config import sysconfig
from ppk.libs._version import __version__


class ArgParser:
    """Command line argument parser for the project."""

    # Project specifics.
    _DESC = 'A Python library and dependency integrity checking utility.'
    _PROG = 'ppk'
    _VERS = __version__
    # Project root directory.
    _D_ROOT = sys.path[0]
    # Help menu options and descriptions.
    _C_PLAT = sysconfig['platforms']
    _C_PVER = sysconfig['pythonversions']
    _H_LICS = 'Display the LICENSE file and exit.'
    _H_BINR = ('Do not use source packages.\n'
               'Packages without binary distributions will fail to\n'
               'download when this option is used on them.')
    _H_NDEP = 'Do not download package dependencies.'
    _H_PKGN = (
               'If *downloading* a single library:\n'
               '  - Name of the library to be downloaded.\n'
               'If *downloading* from requirements (i.e. pip freeze):\n'
               '  - The full path to the requirements.txt file to be used.\n'
               'If *unpacking*:\n'
               '  - The full path to the .7z file to be unpacked.\n\n'

               'If the path to a .txt file is received, the packer will assume\n'
               'this is a requirements file (as generated by \'pip freeze\'), and\n'
               'will be passed into pip download as such.\n\n'

               'If the path to a .7z file is received, the unpacker is called\n'
               'and all other arguments are ignored. If the unpack is successful\n'
               'the environment\'s pip repository is automatically refreshed.'
              )
    _H_PLAT = ('Download only wheels compatible with <platform>.\n'
               'Defaults to the platform of the running system.')
    _H_PVER = ('The Python interpreter version, used for the downloaded\n'
               'wheel(s).\n'
               'Defaults to a version derived from the running\n'
               'interpreter. The version can be specified using\n'
               'a major-minor version given as a string without dots\n'
               '(e.g. "37" for 3.7.0, or "312" for 3.12.0).')
    _H_NOCL = ('Disable the automatic temp file cleanup. Leaves all\n'
               'files in place.')
    _H_USEL = ('Force pip to use the local repository, rather than PyPI.\n'
                    'Generally, this is used for testing only.')

    def __init__(self):
        """Argument parser class initialiser."""
        self._args = None
        self._unpack = False

    @property
    def args(self):
        """Public accessor to parsed command line arguments."""
        return self._args

    @property
    def unpack(self):
        """Signal for the main program to call the unpacker.

        If this property's value is True, the unpacker is called,
        otherwise the packer is called.

        """
        return self._unpack

    def parse(self):
        """Parse command line arguments."""
        # pylint: disable=line-too-long
        parser = argparse.ArgumentParser(prog=self._PROG,
                                         description=self._DESC,
                                         formatter_class=argparse.RawTextHelpFormatter,
                                         epilog=self._epilog())
        parser.add_argument('package', nargs=1, type=str, help=self._H_PKGN)
        parser.add_argument('--no_deps', action='store_true', help=self._H_NDEP)
        parser.add_argument('--only_binary', action='store_true', help=self._H_BINR)
        parser.add_argument('--platform', choices=self._C_PLAT, nargs=1, type=str, help=self._H_PLAT)
        parser.add_argument('--python_version', choices=self._C_PVER, nargs=1, type=str, help=self._H_PVER)
        parser.add_argument('--license', action='store_true', help=self._H_LICS)
        parser.add_argument('-n', '--no_cleanup', action='store_true', help=self._H_NOCL)
        parser.add_argument('-u', '--use_local', action='store_true', help=self._H_USEL)
        parser.add_argument('-v', '--version', action='version', version=self._VERS)
        if '--license' in sys.argv:
            self._display_license()
        else:
            self._args = parser.parse_args()
            self._add_other_arguments()
            self._test_package()

    def _add_other_arguments(self):
        """Update the ``Namespace`` object with additional arguments.

        The arguments added by this method are designed to be privatised
        and 'hidden' from the user, for internal use only.

        """
        self._args.unpack = False
        self._args.from_req = False

    def _display_license(self):
        """Display the project license.

        Once the license file is displayed, the program is exited with
        exit code 0.

        """
        path = os.path.join(self._D_ROOT, 'LICENSE')
        if not os.path.exists(path):
            print('\nThe LICENSE file was not deployed.\n')
        else:
            with open(path, 'r', encoding='utf-8') as f:
                print('\n', f.read())
        sys.exit(0)

    def _epilog(self) -> str:
        """Create the help menu's epilog message.

        Returns:
            str: The string to be displayed as the argparser's epilog.
            If the file is not found (i.e. was not deployed) a
            'no notice' string is returned.

        """
        path = os.path.join(self._D_ROOT, 'NOTICE')
        if not os.path.exists(path):
            return 'The license notice file was not deployed.'
        with open(path, 'r', encoding='utf-8') as f:
            notice = f.read()
        return f'{notice}\n{self._PROG} v{self._VERS}'

    def _test_package(self):
        """Test whether the user is requesting to pack or unpack.

        :Actions:

            - If the argument provided to the ``package`` parameter has a
              ``.txt`` file extension (indicating a requirements file)
              *and* the file exists, the new 'from_req' argument is set
              to True; otherwise it remains as False.
            - If the argument provided to the ``package`` parameter has a
              ``.7z`` file extension (indicating an archive to be passed
              to the unpacker) *and* the file exists, the new 'unpack'
              argument is set to True; otherwise it remains as False.

        Raises:
            FileNotFoundError: If either the TXT or 7zip files do not
            exist.

        """
        # TODO: (Future): Add validation tests to the *package name*,
        #                 if this becomes an issue.
        arg = self._args.package[0]
        if os.path.splitext(arg)[1].lower() == '.txt':
            if not os.path.exists(arg):
                raise FileNotFoundError(f'The requested requirements file was not found: {arg}')
            self._args.from_req = True
        # TODO: Update this to use is7zip (file signature). Requires a utils4 update.
        elif os.path.splitext(arg)[1].lower() == '.7z':
            if not os.path.exists(arg):
                raise FileNotFoundError(f'The requested archive was not found: {arg}')
            self._args.unpack = True


argparser = ArgParser()
